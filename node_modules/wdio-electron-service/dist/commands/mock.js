var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ElectronServiceMock_instances, _ElectronServiceMock_mockFns, _ElectronServiceMock_setMock;
import { fn } from '@vitest/spy';
import log from '../log.js';
export class ElectronServiceMock {
    constructor(apiName) {
        _ElectronServiceMock_instances.add(this);
        _ElectronServiceMock_mockFns.set(this, void 0);
        this.apiName = apiName;
        __classPrivateFieldSet(this, _ElectronServiceMock_mockFns, new Map(), "f");
    }
    async init() {
        const apiFnNames = await browser.electron.execute((electron, apiName) => Object.keys(electron[apiName]).toString(), this.apiName);
        const mockedApis = apiFnNames
            .split(',')
            .reduce((a, funcName) => ({ ...a, [funcName]: 'placeholder' }), {});
        for (const apiFn in mockedApis) {
            mockedApis[apiFn] = await this.initFn(apiFn);
        }
        return mockedApis;
    }
    async initFn(funcName, mockReturnValue) {
        const mock = (await __classPrivateFieldGet(this, _ElectronServiceMock_instances, "m", _ElectronServiceMock_setMock).call(this, funcName, undefined, mockReturnValue));
        mock.mockReturnValue = async (returnValue) => {
            await this.unMock(funcName);
            return await __classPrivateFieldGet(this, _ElectronServiceMock_instances, "m", _ElectronServiceMock_setMock).call(this, funcName, undefined, returnValue);
        };
        mock.mockImplementation = async (implementationFn) => {
            await this.unMock(funcName);
            return await __classPrivateFieldGet(this, _ElectronServiceMock_instances, "m", _ElectronServiceMock_setMock).call(this, funcName, implementationFn);
        };
        mock.update = this.getMock.bind(this, funcName);
        mock.unMock = this.unMock.bind(this, funcName);
        return mock;
    }
    async getMock(funcName) {
        const mockId = `electron.${String(this.apiName)}.${funcName}`;
        log.debug(`getting mock instance for ${mockId}...`);
        if (!funcName) {
            throw new Error(`No mock registered for "${mockId}"`);
        }
        const mock = __classPrivateFieldGet(this, _ElectronServiceMock_mockFns, "f").get(funcName);
        if (!mock) {
            throw new Error(`No mock registered for "${mockId}"`);
        }
        const calls = await browser.electron.execute((electron, apiName, funcName) => electron[apiName][funcName].mock
            .calls, this.apiName, funcName);
        if (!calls) {
            throw new Error(`No mock for ${mockId}() was found!`);
        }
        // re-apply calls from the electron main process mock to this one
        for (const call of calls) {
            mock.apply(mock, call);
        }
        return mock;
    }
    async unMock(funcName) {
        // when funcName is unspecified we unmock all of the mocked functions
        if (!funcName) {
            for (const [mockFnName] of __classPrivateFieldGet(this, _ElectronServiceMock_mockFns, "f")) {
                await this.unMock(mockFnName);
            }
            return;
        }
        __classPrivateFieldGet(this, _ElectronServiceMock_mockFns, "f").delete(funcName);
        await browser.electron.execute((electron, apiName, funcName) => electron[apiName][funcName].revert(), this.apiName, funcName);
    }
}
_ElectronServiceMock_mockFns = new WeakMap(), _ElectronServiceMock_instances = new WeakSet(), _ElectronServiceMock_setMock = async function _ElectronServiceMock_setMock(funcName, mockImplementation = () => { }, mockReturnValue) {
    await browser.electron.execute((electron, apiName, funcName, returnValue) => {
        const electronApi = electron[apiName];
        const originalApi = Object.assign({}, electronApi);
        const mockFn = fn(() => { });
        mockFn.mockReturnValue(returnValue);
        electronApi[funcName] = mockFn;
        electronApi[funcName].revert = () => {
            electronApi[funcName] = originalApi[funcName];
        };
    }, this.apiName, funcName, mockReturnValue);
    const mockFn = fn(mockImplementation);
    __classPrivateFieldGet(this, _ElectronServiceMock_mockFns, "f").set(funcName, mockFn);
    return mockFn;
};
export async function mock(apiName, funcName, mockReturnValue) {
    const electronServiceMock = new ElectronServiceMock(apiName);
    browser.electron._mocks[apiName] = electronServiceMock;
    return await electronServiceMock.initFn(funcName, mockReturnValue);
}
//# sourceMappingURL=mock.js.map